/*------------------------------------------------------------------------------------------------------------------
-- SOURCE FILE: CLIENT.cpp
--
-- PROGRAM:		Windows network lookup application
--
-- FUNCTIONS:	void cl_winsock(HWND, SOCKET*, int, char *, int, int);
--				void ClientProc(HWND, UINT, WPARAM, LPARAM, SOCKET*);
--				void UDPMsgSend(LPSOCKET_INFORMATION SI, SOCKADDR_IN netAddr, int pkSize, int times);
--				void UDPFileSend(LPSOCKET_INFORMATION SI, SOCKADDR_IN netAddr, int pkSize, int times);
--				DWORD WINAPI UDPThread(LPVOID);
--				DWORD WINAPI TCPSendThread(LPVOID);
--				void TCPFileSend(HWND hwnd, SOCKET);
--				void DummyPacket(int packetsize, char *packet);
--				void clDisconnect(SOCKET sock);

--
--
-- DATE:		Feb 05, 2016
--
-- REVISIONS:	
--
-- DESIGNER:	Eunwon Moon
--
-- PROGRAMMER:	Eunwon Moon
--
-- NOTES:
--  Client side to transfer file
----------------------------------------------------------------------------------------------------------------------*/

#include "client.h"
#include "define.h"
#include "winmenu.h"


#pragma comment(lib, "Ws2_32.lib")
#pragma comment(lib,"wininet.lib")

/*---------------------------------------------------------------------------------------
--FUNCTION: 	cv_winsock
--
--DATE :  		Feb 05, 2016
--
--REVISIONS :	Feb 09, 2016	 - add UDP part
--				Feb 11, 2016     - add UDP thread
--				Feb 12, 2016	 - add Ovelapped options
--
--DESIGNER : 	Eunwon Moon
--
--PROGRAMMER : 	Eunwon Moon
--
--INTERFACE : 	void cl_winsock(HWND hwnd, SOCKET* sock, int op_protocol, char* ip_addr, int port, int mesg)
--						   HWND hwnd     : a handle to the winmain window procedure which received the message.
--					UNIT Message  : the received control message which is generated by user action.
--					WPARAM wParam : tha additional message information de
--					LPARAM lParam : the additional message information  

--
--RETURNS : 	void
--
--NOTES :		this is main client function. It open socket and depending on the protocol
--				do WSAConnect or bind and set asyncselect event
--				depending on the mode what the user choose.
--				also set the global value to notify which mode, what kinds of it is.
--
---------------------------------------------------------------------------------------*/
void cl_winsock(HWND hwnd, SOCKET* sock, int op_protocol, char* ip_addr, int port, int mesg)
{
	DWORD Ret;
	SOCKADDR_IN InternetAddr;
	WSADATA wsaData;
	struct hostent *host;
	char temp[512] = "";

	HANDLE ThreadHandle;
	DWORD ThreadId;

	protoMode = op_protocol;
	MesgType = mesg;
	// Prepare echo server
	if ((Ret = WSAStartup(MAKEWORD(2, 2), &wsaData)) != 0)
	{
		wsprintf(temp, "WSAStartup failed with error %d\n", Ret);
		ListOut(temp);
		return;
	}
	switch (protoMode) {
		case TCP:
			if ((*sock = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, 0, 0, WSA_FLAG_OVERLAPPED)) == INVALID_SOCKET)
			{
				wsprintf(temp, "socket() failed with error %d\n", WSAGetLastError());
				ListOut(temp);
				return;
			}
			if (WSAAsyncSelect(*sock, hwnd, WM_TCPCLENT, FD_CONNECT | FD_CLOSE))
			{
				ListOut("WSAASyncSelec fail");
				return;
			};


			if ((host = gethostbyname(ip_addr)) == NULL)
			{
				ListOut("Unable to resolve host name");
				return;
			}


			memset(&InternetAddr, 0, sizeof(InternetAddr));
			InternetAddr.sin_family = PF_INET;
			InternetAddr.sin_port = htons(port);
			InternetAddr.sin_addr.s_addr = *((unsigned long*)host->h_addr);


			WSAConnect(*sock, (SOCKADDR*)&InternetAddr, sizeof(InternetAddr), 0, 0, 0, NULL);
		
			break;


		case UDP:
			if ((*sock = WSASocket(AF_INET, SOCK_DGRAM, IPPROTO_UDP, 0, 0, WSA_FLAG_OVERLAPPED)) == INVALID_SOCKET)
			{
				wsprintf(temp, "socket() failed with error %d\n", WSAGetLastError());
				ListOut(temp);
				return;
			}
			if (WSAAsyncSelect(*sock, hwnd, WM_UDPCLENT, FD_CLOSE))
			{
				ListOut("WSAASyncSelec fail");
				return;
			}
		
		
			if ((host = gethostbyname(ip_addr)) == NULL)
			{
				ListOut("Unable to resolve host name");
				return;
			}
		
			//socket address?!?!
			memset(&InternetAddr, 0, sizeof(InternetAddr));
			InternetAddr.sin_family = PF_INET;
			InternetAddr.sin_port = htons(0);
			InternetAddr.sin_addr.s_addr = htonl(0);

			if (bind(*sock, (PSOCKADDR)&InternetAddr, sizeof(InternetAddr)) == SOCKET_ERROR)
			{
				wsprintf(temp, "bind() failed with error %d\n", WSAGetLastError());
				ListOut(temp);
				return;
			}
			ListOut("UDP CLIENT BINDING ");
			if ((ThreadHandle = CreateThread(NULL, 0, UDPThread, (LPVOID)*sock, 0, &ThreadId)) == NULL)
			{
				wsprintf(temp, "CreateThread failed with error %d\n", GetLastError());
				ListOut(temp);
				return;
			}
	}

}
/*---------------------------------------------------------------------------------------
--FUNCTION: 	UDPThread
--
--DATE :  		Feb 05, 2016
--
--REVISIONS :	Feb 09, 2016	 - add UDP part
--				Feb 11, 2016     - add UDP thread
--				Feb 12, 2016	 - add Ovelapped options
--
--DESIGNER : 	Eunwon Moon
--
--PROGRAMMER : 	Eunwon Moon
--
--INTERFACE : 	void UDPThread(LPVOID lpParameter)
--					LPVOID lpParameter : socket information
--
--RETURNS : 	void
--
--NOTES :
--
---------------------------------------------------------------------------------------*/
DWORD WINAPI UDPThread(LPVOID lpParameter)
{
	LPSOCKET_INFORMATION SocketInfo;
	SOCKADDR_IN InternetAddr;
	CHAR	packetSize_str[STRSIZE], times_str[STRSIZE], port_str[STRSIZE], host_str[STRSIZE];
	DWORD	SendBytes;
	struct hostent *host;

	WSAOVERLAPPED Overlapped = { 0 };
	int		packetsize;
	int		times;
	char	temp[STRSIZE] = "";
	char	*packet;
	DWORD	flag = 0;
	int i = 0;
	int port;
	char filename[STRSIZE];
	FILE *file;


	GetWindowText(hPkSize, packetSize_str, STRSIZE);
	GetWindowText(hNumPk, times_str, STRSIZE);
	GetWindowText(hPort, port_str, STRSIZE);
	GetWindowText(hAddress, host_str, STRSIZE);

	if (strcmp(port_str, "") == 0)
		port = DEFAULTPORT;
	else
		port = atoi(port_str);

	packetsize = atoi(packetSize_str);
	times = atoi(times_str);

	packet = (char*)malloc(sizeof(char)*packetsize);
	
	if ((SocketInfo = (LPSOCKET_INFORMATION)GlobalAlloc(GPTR, sizeof(SOCKET_INFORMATION)))
		== NULL)
	{
		wsprintf(temp, "GlobalAlloc() failed with error %d\n", WSAGetLastError());
		return 1;
	}

	SocketInfo->Overlapped.hEvent = WSACreateEvent();
	SocketInfo->Socket = (SOCKET)lpParameter;
	SocketInfo->DataBuf.len = packetsize;

	if (MesgType == MESGSEND) {
		DummyPacket(packetsize, packet);
		SocketInfo->DataBuf.buf = packet;
	}
	
	else {
		GetWindowText(hFileT, filename, STRSIZE);
		file = fopen(filename, "rb+");
		if (file == NULL)
		{
			ListOut("File Open Fail.");
			wsprintf(temp, "ERROR CODE IS %d", GetLastError());
			ListOut(temp);
			return -1;
		}
	}



	if ((host = gethostbyname(host_str)) == NULL)
	{
		ListOut("Unable to resolve host name");
		return 2;
	}

	memset(&InternetAddr, 0, sizeof(InternetAddr));

	InternetAddr.sin_family = PF_INET;
	InternetAddr.sin_port = htons(port);
	InternetAddr.sin_addr.s_addr = *((unsigned long*)host->h_addr);
	
	ListOut("START SEND");
	if (MesgType == MESGSEND) {
		UDPMsgSend(SocketInfo, InternetAddr, packetsize, times);

	}
	else {
		UDPFileSend(SocketInfo, InternetAddr, packetsize, times);
	}

	wsprintf(temp, "UDP SEND TOTAL %d\n", SocketInfo->BytesSEND);
	ListOut(temp);

	free(packet);
	return 0;
}

/*---------------------------------------------------------------------------------------
--FUNCTION: 	ClientProc
--
--DATE :  		Feb 05, 2016
--
--REVISIONS :	Feb 09, 2016	 - add UDP part
--				Feb 11, 2016     - add UDP thread
--				Feb 12, 2016	 - add Ovelapped options
--
--DESIGNER : 	Eunwon Moon
--
--PROGRAMMER : 	Eunwon Moon
--
--INTERFACE : 	void ClientProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, SOCKET* sock)
--					HWND hwnd     : a handle to the winmain window procedure which received the message.
--					UNIT Message  : the received control message which is generated by user action.
--					WPARAM wParam : tha additional message information de
--					LPARAM lParam : the additional message information
--					SOCKET *sock  : socket information which is connected before
--
--RETURNS : 	void
--
--NOTES :		This is the Event which is set using WSAASyncSelect.
--
---------------------------------------------------------------------------------------*/
void ClientProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, SOCKET* sock)
{
	int i = 0;
	char temp[512];
	HANDLE ThreadHandle;
	DWORD ThreadId;

	if (uMsg == WM_TCPCLENT) {
		//error message
		if (WSAGETSELECTERROR(lParam))
		{

			wsprintf(temp, " WSAGETSELERROR Socket failed with error %d\n", WSAGETSELECTERROR(lParam));
			ListOut(temp);
		}
		else
		{
			switch (WSAGETSELECTEVENT(lParam))
			{
			case FD_CONNECT:
				WSAAsyncSelect(*sock, hwnd, WM_TCPCLENT, FD_WRITE | FD_CLOSE);
				break;

			case FD_WRITE:

				if (MesgType == MESGSEND) {

					if ((ThreadHandle = CreateThread(NULL, 0, TCPSendThread, (LPVOID)*sock, 0, &ThreadId)) == NULL)
					{
						wsprintf(temp, "CreateThread failed with error %d\n", GetLastError());
						ListOut(temp);
						return;
					}
				}
				else
					TCPFileSend(hwnd, *sock);

				break;

			case FD_CLOSE:
				closesocket(*sock);

				printf("Server Closing socket %d\n", wParam);
				ListOut("*******************************************************");
				ListOut(" ");

				break;
			}
		}
	}
	if (uMsg == WM_UDPCLENT) {
		//error message
		if (WSAGETSELECTERROR(lParam))
		{
			wsprintf(temp, " WSAGETSELERROR Socket failed with error %d\n", WSAGETSELECTERROR(lParam));
			ListOut(temp);
		}
		else
		{
			switch (WSAGETSELECTEVENT(lParam))
			{
				case FD_CLOSE:
					closesocket(*sock);
					printf("Closing socket %d\n", wParam);
					break;
			}
		}
	}

}

/*---------------------------------------------------------------------------------------
--FUNCTION: 	TCPSendThread
--
--DATE :  		Feb 05, 2016
--
--REVISIONS :	Feb 09, 2016	 - add UDP part
--				Feb 11, 2016     - add UDP thread
--				Feb 12, 2016	 - add Ovelapped options
--
--DESIGNER : 	Eunwon Moon
--
--PROGRAMMER : 	Eunwon Moon
--
--INTERFACE : DWORD WINAPI TCPSendThread(LPVOID sock)
--					LPVOID sock : socket information which is from cl_winsock
--
--RETURNS : 	DWORD
--
--NOTES :		This is thread for TCP Send
--				Get value of packet size and times to send, and send
--				meaningless data based on value from Dialog input
--
---------------------------------------------------------------------------------------*/
DWORD WINAPI TCPSendThread(LPVOID sock) {
	char size_str[STRSIZE], times_str[STRSIZE];
	int packetsize;
	int times;
	int i = 0;
	char temp[512];
	char *packet;
	LPSOCKET_INFORMATION SocketInfo;
	DWORD  SendBytes;
	DWORD err;

	GetWindowText(hPkSize, size_str, STRSIZE);
	GetWindowText(hNumPk, times_str, STRSIZE);
	wsprintf(temp, "STR SIZE: %s, TIMES: %s", size_str, times_str);
	ListOut(temp);
	packetsize = atoi(size_str);
	times = atoi(times_str);
	i = 0;
	packet = (char*)malloc(sizeof(char)*packetsize);

	if ((SocketInfo = (LPSOCKET_INFORMATION)GlobalAlloc(GPTR, sizeof(SOCKET_INFORMATION)))
		== NULL)
	{
		wsprintf(temp, "GlobalAlloc() failed with error %d\n", WSAGetLastError());
		return -1;
	}
	DummyPacket(packetsize, packet);
	SocketInfo->Socket = (SOCKET)sock;
	SocketInfo->Overlapped.hEvent = WSACreateEvent();
	SocketInfo->DataBuf.buf = packet;
	SocketInfo->DataBuf.len = packetsize;

	while (i  < times) {
		if (WSASend(SocketInfo->Socket, &(SocketInfo->DataBuf), 1, &SendBytes, 0,
			&(SocketInfo->Overlapped), NULL) == SOCKET_ERROR)
		{
			if (WSAGetLastError() != WSAEWOULDBLOCK && WSAGetLastError() != WSA_IO_PENDING)
			{
				wsprintf(temp, "WSASend() failed with error %d\n", WSAGetLastError());
				ListOut(temp);
				return -1;
			}

		}

		err = WSAWaitForMultipleEvents(1, &SocketInfo->Overlapped.hEvent, FALSE, 100, FALSE);
		if (err == WAIT_TIMEOUT) {
			ListOut("READ DOME");
			clDisconnect(SocketInfo->Socket);
			return -1;
		}

		SocketInfo->BytesSEND += SendBytes;
		i++;

		memset(&SocketInfo->Overlapped, '\0', sizeof(SocketInfo->Overlapped));
		SocketInfo->Overlapped.hEvent = WSACreateEvent();
	}

	wsprintf(temp, "[%d] SEND SIZE %d, TOTAL %d\n", i, SendBytes, SocketInfo->BytesSEND);
	ListOut(temp);
	ListOut("FINISHED");
	clDisconnect(SocketInfo->Socket);
	free(packet);
	return 0;
}



/*---------------------------------------------------------------------------------------
--FUNCTION: 	 TCPFileSend
--
--DATE :  		Feb 05, 2016
--
--REVISIONS :	Feb 12, 2016	 - add Ovelapped options
--
--DESIGNER : 	Eunwon Moon
--
--PROGRAMMER : 	Eunwon Moon
--
--INTERFACE :	void  TCPFileSend(HWND hwnd, SOCKET sock)
--						    HWND	hwnd:
--							SOCKET	sock:
--
--RETURNS : 	void
--
--NOTES :		This is to send file using TCP
--				get filename from the dialg and try to open.
--				IF it is open, read stream as much as the user want to send, 
--				and send using WSASend function
--				if there is overlapped, waiting for next event.
--
---------------------------------------------------------------------------------------*/
void TCPFileSend(HWND hwnd, SOCKET sock) {

	int packetSize;
	char filename[STRSIZE];
	FILE *file;
	char temp[STRSIZE];
	DWORD dwBytesSend = 0;
	DWORD err;
	int i;

	LPSOCKET_INFORMATION SI;

	packetSize = GetDlgItemInt(hwnd, IDC_EDIT_SIZE, NULL, TRUE);
	GetDlgItemText(hwnd, IDC_EDIT_FILE, filename, STRSIZE);

	char * packet = (char*)malloc((sizeof(char) * packetSize) + 1);


	file = fopen(filename, "rb+");
	if (file == NULL)
	{
		ListOut("File Open Fail.");
		wsprintf(temp, "ERROR CODE IS %d", GetLastError());
		return;
	}

	if ((SI = (LPSOCKET_INFORMATION)GlobalAlloc(GPTR, sizeof(SOCKET_INFORMATION)))
		== NULL)
	{
		wsprintf(temp, "GlobalAlloc() failed with error %d\n", WSAGetLastError());
		fclose(file);
		return;
	}
	SI->Socket = (SOCKET)sock;
	SI->DataBuf.len = packetSize;
	while (!feof(file)) {

		fread(packet, sizeof(char), packetSize, file);
		SI->DataBuf.buf = packet;
		memset(&SI->Overlapped, '\0', sizeof(SI->Overlapped));
		SI->Overlapped.hEvent = WSACreateEvent();

		if (WSASend(SI->Socket, &(SI->DataBuf), 1, &dwBytesSend, 0, &(SI->Overlapped), NULL) == SOCKET_ERROR)
		{
			if (WSAGetLastError() != WSAEWOULDBLOCK && WSAGetLastError() != WSA_IO_PENDING)
			{
				wsprintf(temp, "FILESEND WSASend() failed with error %d\n", WSAGetLastError());
				ListOut(temp);
				fclose(file);
				return;
			}
		}

		err = WSAWaitForMultipleEvents(1, &SI->Overlapped.hEvent, FALSE, 100, FALSE);
		if (err == WAIT_TIMEOUT) {
			ListOut("READ DOME");
			fclose(file);
			return;
		}
		SI->BytesSEND += dwBytesSend;
	}

	wsprintf(temp, " SEND SIZE %d, TOTAL %d\n", dwBytesSend, SI->BytesSEND);
	ListOut(temp);
	fclose(file);
	free(packet);
	clDisconnect(SI->Socket);
	WSACleanup();
}

/*---------------------------------------------------------------------------------------
--FUNCTION: 	UDPMsgSend
--
--DATE :  		Feb 11, 2016
--
--REVISIONS :	Feb 12, 2016	 - add Ovelapped options
--
--DESIGNER : 	Eunwon Moon
--
--PROGRAMMER : 	Eunwon Moon
--
--INTERFACE : 	void UDPMsgSend(LPSOCKET_INFORMATION SI, SOCKADDR_IN netAddr, int pkSize, int times )
--					LPSOCKET_INFORMATION SI : socket information to use
--					SOCKADDR_IN netAddr		: socket address information
--					int pkSize				: packet size to send
--					int times				: the number of packet to send
--
--RETURNS : 	void
--
--NOTES :	This is to send dummy data as much as the client user want to send
--			Make a dummydata size of pkSize, and send using WSASendTo
--			to prevent missing data before sending, use Overlapped
--
---------------------------------------------------------------------------------------*/
void UDPMsgSend(LPSOCKET_INFORMATION SI, SOCKADDR_IN netAddr, int pkSize, int times )
{
	char *packet;
	DWORD	SendBytes;
	char	temp[STRSIZE] = "";
	DWORD	flag = 0;
	int i = 0;

	packet = (char*)malloc(sizeof(char)*pkSize);
	DummyPacket(pkSize, packet);
	SI->DataBuf.buf = packet;
	SI->Overlapped = { 0 };
	ListOut("START SEND");

	while (i++ < times) {
		memset(&SI->Overlapped, '\0', sizeof(SI->Overlapped));
		SI->Overlapped.hEvent = WSACreateEvent();
		if (WSASendTo(SI->Socket, &(SI->DataBuf), 1, &SendBytes, flag,
			(SOCKADDR *)&netAddr, sizeof(netAddr), &SI->Overlapped, NULL) == SOCKET_ERROR)
		{
			if (WSAGetLastError() != WSAEWOULDBLOCK && WSAGetLastError() != WSA_IO_PENDING)
			{
				wsprintf(temp, "WSASend() failed with error %d\n", WSAGetLastError());
				ListOut(temp);
				return ;
			}
		}
		
		if (WSAWaitForMultipleEvents(1, &SI->Overlapped.hEvent, FALSE, 500, FALSE) == WAIT_TIMEOUT) {
			ListOut("Time Out");
			return;
		}
		SI->BytesSEND += SendBytes;
	}
	wsprintf(temp, " SEND SIZE %d, TOTAL %d\n", SendBytes, SI->BytesSEND);
	ListOut(temp);
	free(packet);
}


/*---------------------------------------------------------------------------------------
--FUNCTION: 	 UDPFileSend
--
--DATE :  		Feb 05, 2016
--
--REVISIONS :	Feb 12, 2016	 - add Ovelapped options
--
--DESIGNER : 	Eunwon Moon
--
--PROGRAMMER : 	Eunwon Moon
--
--INTERFACE :	void  UDPFileSend(HWND hwnd, SOCKET sock)
--						    HWND	hwnd:
--							SOCKET	sock:
--
--RETURNS : 	void
--
--NOTES :		This is to send file using UDP
--				get filename from the dialg and try to open.
--				IF it is open, read stream as much as the user want to send,
--				and send using WSASendto function
--				if there is overlapped, waiting for next event.
--
---------------------------------------------------------------------------------------*/

void UDPFileSend(LPSOCKET_INFORMATION SI, SOCKADDR_IN netAddr, int pkSize, int times) {
	DWORD	SendBytes;
	char	temp[STRSIZE] = "";
	char	*packet;
	DWORD	flag = 0;
	char filename[STRSIZE];
	FILE *file;
	DWORD err;

	packet = (char*)malloc(sizeof(char)*pkSize);

	//read value
	GetWindowText(hFileT, filename, STRSIZE);

	//openfile
	file = fopen(filename, "rb+");
	if (file == NULL)
	{
		ListOut("File Open Fail.");
		return ;
	}

	//initialize overlapped
	SI->Overlapped = { 0 };
	ListOut("START SEND");


	//read file and send until the file finished
	while (!feof(file)) {
		//initialize ovelapped event
		memset(&SI->Overlapped, '\0', sizeof(SI->Overlapped));
		SI->Overlapped.hEvent = WSACreateEvent();

		//read file
		fread(packet, sizeof(char), pkSize, file);
		SI->DataBuf.buf = packet;
		
		//send file
		if (WSASendTo(SI->Socket, &(SI->DataBuf), 1, &SendBytes, flag,
			(SOCKADDR *)&netAddr, sizeof(netAddr), &SI->Overlapped, NULL) == SOCKET_ERROR)
		{
			if (WSAGetLastError() != WSAEWOULDBLOCK && WSAGetLastError() != WSA_IO_PENDING)
			{
				wsprintf(temp, "WSASend() failed with error %d\n", WSAGetLastError());
				ListOut(temp);
				return ;
			}
		}
		//detect error if overlapped
		err = WSAWaitForMultipleEvents(1, &SI->Overlapped.hEvent, FALSE, 500, FALSE);
		if (err == WAIT_TIMEOUT) {
			ListOut("TIMEOUT");
			return ;
		}
		//accumulate sendbytes
		SI->BytesSEND += SendBytes;

	}
	wsprintf(temp, " SEND SIZE %d, TOTAL %d\n", SendBytes, SI->BytesSEND);
	ListOut(temp);
	free(packet);
	fclose(file);

}



/*---------------------------------------------------------------------------------------
--FUNCTION: 	 DummyPacket
--
--DATE :  		Feb 05, 2016
--
--REVISIONS :	
--
--DESIGNER : 	Eunwon Moon
--
--PROGRAMMER : 	Eunwon Moon
--
--INTERFACE :	 DummyPacket(int packetsize, char * packet)
--						    int packetsize	: size of packet
--							char * packet	: store the packet value
--
--
--RETURNS : 	DWORD
--
--NOTES :		This is to make dummy data as much as the client 
--
---------------------------------------------------------------------------------------*/
void DummyPacket(int packetsize, char * packet)
{

	int i;
	for ( i = 0; i < packetsize; i++)
		packet[i] = 'a';
	packet[i] += '\0';
}


/*---------------------------------------------------------------------------------------
--FUNCTION: 	clDisconnect
--
--DATE :  		Feb 13, 2016
--
--REVISIONS :	
--
--DESIGNER : 	Eunwon Moon
--
--PROGRAMMER : 	Eunwon Moon
--
--INTERFACE : 	void clDisconnect(SOCKET sock)
--						SOCKET sock : socket information
--
--RETURNS : 	void
--
--NOTES : This is to close the socket before finishing.
--
---------------------------------------------------------------------------------------*/

void clDisconnect(SOCKET sock) {
	ListOut("*******************************************************");
	ListOut(" ");
	shutdown(sock, SD_BOTH);
	closesocket(sock);
	WSACleanup();
}