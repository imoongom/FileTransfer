/*------------------------------------------------------------------------------------------------------------------
-- SOURCE FILE: CLIENT.cpp
--
-- PROGRAM:		Windows network lookup application
--
-- FUNCTIONS:	void sv_disconn(SOCKET);
--				LPSOCKET_INFORMATION SocketInfo;
--				DWORD WINAPI UDPServThread(LPVOID);
--				DWORD WINAPI TCPRecvThread(LPVOID);
--
--
-- DATE:		Feb 05, 2016
--
-- REVISIONS:
--
-- DESIGNER:	Eunwon Moon
--
-- PROGRAMMER:	Eunwon Moon
--
-- NOTES:
--  Serverside to receive file
----------------------------------------------------------------------------------------------------------------------*/
#include "server.h"
#include "winmenu.h"
#include "define.h"



/*---------------------------------------------------------------------------------------
--FUNCTION: 	sv_winsock
--
--DATE :  		Feb 05, 2016
--
--REVISIONS :	Feb 09, 2016	 - add UDP part
--				Feb 11, 2016     - add UDP thread
--				Feb 13, 2016	 - add Ovelapped options
--
--DESIGNER : 	Eunwon Moon
--
--PROGRAMMER : 	Eunwon Moon
--
--INTERFACE : 	sv_winsock(HWND hwnd,  SOCKET* sock, int op_no, int port_num)
--						    LPVOID sock :

--
--RETURNS : 	void
--
--NOTES :		this is main server function. It open socket and depending on the protocol
--				do WSAConnect or bind and set asyncselect event.
--				depending on the mode what the user choose.
--				also for UDP create thread to receive message
--
---------------------------------------------------------------------------------------*/
void sv_winsock(HWND hwnd,  SOCKET* sock, int op_no, int port_num)
{
	MSG msg;
	DWORD Ret;

	SOCKADDR_IN InternetAddr;
	WSADATA wsaData;
	char temp[512] = "";
	HANDLE ThreadHandle;
	DWORD ThreadId;
	
	//initialize global variable
	RecvDataCal = 0;
	bool RdNotStart = true;
	bool firstRecv = false;

	// Prepare echo server
	if ((Ret = WSAStartup(0x0202, &wsaData)) != 0)
	{
		wsprintf(temp,"WSAStartup failed with error %d\n", Ret);
		ListOut(temp);
		return;
	}
	RdNotStart = true;

	switch (op_no) {
		case TCP:
			if ((*sock = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, 0, 0, WSA_FLAG_OVERLAPPED)) == INVALID_SOCKET)
			{
				wsprintf(temp,"socket() failed with error %d\n", WSAGetLastError());
				ListOut(temp);
				return;
			}

			WSAAsyncSelect(*sock, hwnd, WM_TCPSERV, FD_ACCEPT | FD_CLOSE);

			InternetAddr.sin_family = AF_INET;
			InternetAddr.sin_addr.s_addr = htonl(INADDR_ANY);
			InternetAddr.sin_port = htons(port_num);


			if (bind(*sock, (PSOCKADDR)&InternetAddr, sizeof(InternetAddr)) == SOCKET_ERROR)
			{
				wsprintf(temp, "bind() failed with error %d\n", WSAGetLastError());
				ListOut(temp);
				return;
			}

			if (listen(*sock, 5))
			{
				wsprintf(temp, "listen() failed with error %d\n", WSAGetLastError());
				ListOut(temp);
				return;
			}
			break;

		case UDP:
			if ((*sock = WSASocket(AF_INET, SOCK_DGRAM, IPPROTO_UDP, 0, 0, WSA_FLAG_OVERLAPPED)) == INVALID_SOCKET)
			{
				wsprintf(temp, "socket() failed with error %d\n", WSAGetLastError());
				ListOut(temp);
				return;
			}
			if (WSAAsyncSelect(*sock, hwnd, WM_UDPSERV, FD_READ|FD_CLOSE))
			{
				ListOut("WSAASyncSelec fail");
				return;
			};

			udpread = CreateEvent(NULL, TRUE, FALSE, "startreading");

			memset(&InternetAddr, 0, sizeof(InternetAddr));
			InternetAddr.sin_family = AF_INET;
			InternetAddr.sin_addr.s_addr = htonl(INADDR_ANY);
			InternetAddr.sin_port = htons(port_num);

			if (bind(*sock, (PSOCKADDR)&InternetAddr, sizeof(InternetAddr)) == SOCKET_ERROR)
			{
				wsprintf(temp, "bind() failed with error %d\n", WSAGetLastError());
				ListOut(temp);
				return;
			}

			if ((ThreadHandle = CreateThread(NULL, 0, UDPServThread, (LPVOID) *sock, 0, &ThreadId)) == NULL)
			{
				wsprintf(temp, "CreateThread failed with error %d\n", GetLastError());
				ListOut(temp);
				return;
			}
	
	}

}
/*---------------------------------------------------------------------------------------
--FUNCTION: 	ServWinProc
--
--DATE :  		Feb 05, 2016
--
--REVISIONS :
--
--DESIGNER : 	Eunwon Moon
--
--PROGRAMMER : 	Eunwon Moon
--
--INTERFACE : 	void ServWinProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, SOCKET * sock)
--					HWND hwnd     : a handle to the winmain window procedure which received the message.
--					UNIT Message  : the received control message which is generated by user action.
--					WPARAM wParam : tha additional message information de
--					LPARAM lParam : the additional message information  
--					SOCKET * sock : server socket pointer which is in main
--
--RETURNS : 	void
--
--NOTES :		This is the Event signal which is set using WSAASyncSelect.
--
---------------------------------------------------------------------------------------*/
void ServWinProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, SOCKET * sock)
{
	SOCKET Accept;
	SOCKADDR_IN sockaddr;
	int sockSize = sizeof(sockaddr);
	DWORD RecvBytes, SendBytes;
	DWORD Flags = 0;

	char temp[STRSIZE] = "";
	CHAR Buffer[DATA_BUFSIZE];

	
	HANDLE ThreadHandle;
	DWORD ThreadId;


	switch (uMsg) {
	case WM_TCPSERV:
		//error message
		if (WSAGETSELECTERROR(lParam))
		{
			wsprintf(temp, "Socket failed with error %d\n", WSAGETSELECTERROR(lParam));
			ListOut(temp);
			return;
		}
		else
		{
			switch (WSAGETSELECTEVENT(lParam))
			{
			case FD_ACCEPT:
				if ((Accept = WSAAccept(*sock, (SOCKADDR*)&sockaddr, &sockSize, NULL, NULL)) == INVALID_SOCKET)
				{
					printf("accept() failed with error %d\n", WSAGetLastError());
					break;
				}

				wsprintf(temp, "Socket number %d connected\n", *sock);
				ListOut(temp);
				RecvDataCal = 0;
				*sock = Accept;

				WSAAsyncSelect(Accept, hwnd, WM_TCPSERVCONN, FD_READ | FD_CLOSE);
				break;

			case FD_CLOSE:

				wsprintf(temp, "Closing socket %d\n", wParam);
				ListOut(temp);
				sv_disconn(*sock);
				break;
			}
		}
		break;
	case WM_TCPSERVCONN:
		//error message
		if (WSAGETSELECTERROR(lParam))
		{
			printf("Socket failed with error %d\n", WSAGETSELECTERROR(lParam));
		}
		else
		{
			switch (WSAGETSELECTEVENT(lParam))
			{

			case FD_READ:
				if ((SocketInfo = (LPSOCKET_INFORMATION)GlobalAlloc(GPTR, sizeof(SOCKET_INFORMATION)))
					== NULL)
				{
					wsprintf(temp, "GlobalAlloc() failed with error %d\n", WSAGetLastError());
					return;
				}
				SocketInfo->Socket = *sock;
				SocketInfo->DataBuf.buf = Buffer;
				SocketInfo->DataBuf.len = DATA_BUFSIZE;
				memset(&SocketInfo->Overlapped, '\0', sizeof(SocketInfo->Overlapped));
				SocketInfo->Overlapped.hEvent = WSACreateEvent();

				if (WSARecv(*sock, &(SocketInfo->DataBuf), 1, &RecvBytes,
					&Flags, &SocketInfo->Overlapped, NULL) == SOCKET_ERROR)
				{
					if (WSAGetLastError() != WSAEWOULDBLOCK && WSAGetLastError() != ERROR_IO_PENDING)
					{
						wsprintf(temp, "WSARecv() failed with error %d\n", WSAGetLastError());
						ListOut(temp);
						return;
					}
				}
				//when receive first packet, store star time
				if (!firstRecv && RecvBytes>0 ) {
					t1 = high_resolution_clock::now();
					firstRecv = true;
				}

				RecvDataCal += RecvBytes;

				t2 = high_resolution_clock::now();
				break;


			case FD_CLOSE:
				sprintf(temp, "Client Closing socket %d\n", wParam);
				ListOut(temp);

				ServerResult();
				firstRecv = false;
				sv_disconn(*sock);

				break;
			
			}
		}
		break;
	case WM_UDPSERV:
		if (WSAGETSELECTERROR(lParam))
		{
			wsprintf(temp, "Socket failed with error %d\n", WSAGETSELECTERROR(lParam));
			ListOut(temp);
			return;
		}
		else
		{
			switch (WSAGETSELECTEVENT(lParam))
			{
			case FD_READ:
				if (RdNotStart) {
					RdNotStart = false;
					SetEvent(udpread);
				}
				break;

			case FD_CLOSE:
				sv_disconn(*sock);
				wsprintf(temp, "Closing socket %d\n", wParam);
				ListOut(temp);

				break;
			}
		}

	}

}

/*---------------------------------------------------------------------------------------
--FUNCTION: 	UDPServThread
--
--DATE :  		Feb 13, 2016
--
--REVISIONS :
--
--DESIGNER : 	Eunwon Moon
--
--PROGRAMMER : 	Eunwon Moon
--
--INTERFACE : 	DWORD WINAPI UDPServThread(LPVOID sock)
--						    LPVOID sock : socket information 

--
--RETURNS : 	void
--
--NOTES :		This function is UDP received function.
--				It is prepared to receive and stucked
--				until get event from FD_read after receiving first packet
--				It saved file everytime read.
--
---------------------------------------------------------------------------------------*/
DWORD WINAPI UDPServThread(LPVOID sock)
{
	LPSOCKET_INFORMATION SocketInfo;
	SOCKADDR_IN InternetAddr;
	CHAR	packetSize_str[STRSIZE], times_str[STRSIZE], port_str[STRSIZE], host_str[STRSIZE];
	DWORD	RecvBytes;
	CHAR Buffer[DATA_BUFSIZE];
	WSAOVERLAPPED Overlapped = { 0 };
	DWORD flags = 0;
	char	temp[STRSIZE] = "";
	int port = DEFAULTPORT;
	int i = 0;
	int destlen;
	bool startRecv =  false;
	FILE *RcvFile;
	char rcvFileName[STRSIZE];

	//READ port and address value
	GetWindowText(hPort, port_str, STRSIZE);
	GetWindowText(hAddress, host_str, STRSIZE);

	//update port value if it is not null
	if (strcmp(port_str, "") != 0)
		port = atoi(port_str);

	//open file to write
	wsprintf(rcvFileName, "sv_%d.txt", sock);
	RcvFile = fopen(rcvFileName, "wb+");
	if (RcvFile == NULL)
	{
		ListOut("file recv File Open Fail.");
		return -1;
	}

	//alloc socket_information
	if ((SocketInfo = (LPSOCKET_INFORMATION)GlobalAlloc(GPTR, sizeof(SOCKET_INFORMATION)))
		== NULL)
	{
		wsprintf(temp, "GlobalAlloc() failed with error %d\n", WSAGetLastError());
		ListOut(temp);
		return -1;
	}

	// initialize address information
	memset(&InternetAddr, 0, sizeof(InternetAddr));
	InternetAddr.sin_family = AF_INET;
	InternetAddr.sin_addr.s_addr = htonl(INADDR_ANY);
	InternetAddr.sin_port = htons(port);


	//initialize socket information
	SocketInfo->Overlapped.hEvent = WSACreateEvent();
	SocketInfo->Socket = (SOCKET)sock;
	SocketInfo->DataBuf.buf = Buffer;
	SocketInfo->DataBuf.len = DATA_BUFSIZE;

	destlen = sizeof(SOCKADDR_IN);

	
	while (1) {
		//if server receive a packet in Fd_READ, get event
		WaitForSingleObject(udpread, INFINITE);
		ResetEvent(udpread);

		//check first packet received time 
		if (!startRecv) {
			t1 = high_resolution_clock::now();
			startRecv = true;
		}

		//read message until timeout
		while (1) {

			memset(&SocketInfo->Overlapped, '\0', sizeof(SocketInfo->Overlapped));
			SocketInfo->Overlapped.hEvent = WSACreateEvent();

			if (WSARecvFrom(SocketInfo->Socket, &(SocketInfo->DataBuf), 1, &RecvBytes, &flags,
				(SOCKADDR *)&InternetAddr, &destlen, &SocketInfo->Overlapped, NULL) == SOCKET_ERROR)
			{
				if (WSAGetLastError() != WSAEWOULDBLOCK && WSAGetLastError() != WSA_IO_PENDING)
				{
					wsprintf(temp, "udp thread WSARecvFrom() failed with error %d\n", WSAGetLastError());
					ListOut(temp);
					fclose(RcvFile);
					return 3;
				}
			}

			if (WSAWaitForMultipleEvents(1, &SocketInfo->Overlapped.hEvent, FALSE, 500, FALSE) == WAIT_TIMEOUT) {
				ServerResult();
				startRecv = false;
				fclose(RcvFile);
				RdNotStart = true;
				//sv_disconn((SOCKET)sock);
				return 0;
			}

			t2 = high_resolution_clock::now();	//update time to received
			RecvDataCal += RecvBytes;


			fwrite(SocketInfo->DataBuf.buf, sizeof(char), RecvBytes, RcvFile);
		}
	}
	return -1;
}


/*---------------------------------------------------------------------------------------
--FUNCTION: 	sv_disconnt
--
--DATE :  		Feb 13, 2016
--
--REVISIONS :
--
--DESIGNER : 	Eunwon Moon
--
--PROGRAMMER : 	Eunwon Moon
--
--INTERFACE : 	void ServerResult(SOCKET sock)
--					Socket sock : the socket information to close
--
--RETURNS : 	void
--
--NOTES : This is to close the socket before finishing.
--
---------------------------------------------------------------------------------------*/
void sv_disconn(SOCKET sock) {
	shutdown(sock, SD_BOTH);
	closesocket(sock);
	WSACleanup();
}


/*---------------------------------------------------------------------------------------
--FUNCTION: 	ServerResult
--
--DATE :  		Feb 13, 2016
--
--REVISIONS :
--
--DESIGNER : 	Eunwon Moon
--
--PROGRAMMER : 	Eunwon Moon
--
--INTERFACE : 	void ServerResult()

--
--RETURNS : 	void
--
--NOTES : This is to Display statistic information to received from client.
--
---------------------------------------------------------------------------------------*/
void ServerResult() {

	char temp[STRSIZE] = "";
	auto duration = duration_cast<microseconds>(t2 - t1).count();
	double timeGap = (double)duration;
	sprintf(temp, "Recv Data total %d, time : %0.2f us", RecvDataCal, timeGap);
	ListOut(temp);
	sprintf(temp, "          Speed : %0.2f MB/s", duration==0? 0:(double)(RecvDataCal / timeGap));
	ListOut(temp);
	ListOut("**********************************************");
	ListOut(" ");

}
